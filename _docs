importing a function from a package
from functools import reduce

##Syntax
List --> l = [a,b,d,e,c]
calling List --> l[0] gives element a, l[-1] gives element c
slicing list --> l[2:4] gives d,e
concat/adding list --> l + [f,g] => [a,b,d,e,c,f,g]
delete element from list --> del(l[2]) => [a,b,e,c]
get index of element --> l.index("c") => 4
adding element in the end --> l.append('k')

length of string/list --> len(str)
calling substring --> str[2:7]

numpy array --> np_arr = np.array(["a","b","c"])
size of numpy array --> np_arr.shape
calling element from numpy array --> np_arr[0,2] gives "c"
np.logical_and(),np.logical_or(),np.logical_not() are used as logical operators on numpy arrays
looping over 2D np.array
for val in np.nditer(np_2d_arr)

plotting
making a plot --> plt.plot(x_axis,y_axis) {two dimensional}     plt.plot(y_axis) {one dimensional--set integer on x-axis}
showing plot on screen --> plt.show()
scatter plot --> plt.scatter(x_vals,y_vals)
histogram --> plt.hist(vals,bin_nos)
plt.xlabel(x_lab)
plt.ylabel(y_lab)
plt.title(title)

Dictionaries
making dictionaries --> dict = {"a":1,"b":2,"c":3}
calling value in dict --> dict["b"] => 2
delete a key-value pair --> del(dict["c"]) => {"a":1,"b":2}
looping over dictionary
for key,value in dict.items()
adding element in dictonary --> langs_count["d"]=4

DataFrame
making dataframe --> df = pd.DataFrame(dict)
empty dataframe   --> df = pd.DataFrame()
setting label --> df.label = label_list
DataFrame from a csv --> pd.csv_read('names.csv' , index_col = 0{specifying index column})[can use read_csv(file) also]
              for chunk in pd.read_csv('data.csv', chunksize=1000{specifying the size of chunk to take at once})
selecting a column --> brics['country']  (this returns a pandas series with labels)
                   --> brics[['country']] (this returns a pandas DataFrame)
selecting a rows   --> brics[1:4] outputs rows 2,3 and 4
                   --> brics.loc['RU'] => row with 'RU' label (type is a pd series)
                   --> brics.loc[['RU']] => row with 'RU' label (type is a pd DataFrame)
selecting specific rows and cols  --> brics.loc[["RU","IN"],["country"]] => country col of rows 'RU' and 'IN'
use brics.loc[:,["country"]] to get full 'country column'
use iloc if you want to access data using positions
selecting rows using some condition --> brics[brice['area']>8]
looping over DataFrame
for label,row in df.iterrows()    =>  label contains label of hte row, row contains data of the row as pandas series
brics["a"] = brics["b"].apply(len)  --> apply len function on "b" column of brics and save that to column "a"
appending to a dataframe  --> df.append(df2)
df.head() --> display first 5 values and header
df.vaues  --> covert to numpy array
read_csv(header = None/0/1, nrows=5{no of rows to parse}, sep= '\t'{data separator}, comment='#'{cosider line 
          after # as comment and ignore}, na_values=['nothing']{list of strings to consider as NaN})
read excel file --> data = pd.ExcelFile(file)
                    data.sheet_names  --> gives name of sheets in the excel file
                    data.parse(sheetname/sheet_index, skip_rows=[0,1], names=['Country','State'], 
                    parse_cols=[0]) --> parse the specified sheet in dataframe

for loop
for height in fam:
  print(fam)          =>  this prints all height in fam list

for index,height in enumerate(fam):   =>    gives index as well as height from fam list

Random number generator --> np.random.rand()
----- "" ---- seed  --> np.random.seed(123)
Random integer generator --> np.random.randint(0,7) => generate random integer from 0 to 6

1 to 100 series --> range(100)

function defination:-
def square(orig_no,pow = 1{default argument}):
  """Returns squre of a value"""      --> docstrings
  new_val = orig_val ** pow
  return new_val
return a tuple if you want to return more than 1 result
pass multiple arguments --> *args
pass multiple arguments with arguments --> **kwargs
  
tuple
t = (2,3,4)
a,b,c = t   -> a => 2, b=>3, c=>4
accessing an element  -->   t[1] => 3

Lamda functions syntax
rtp = lamda x, y: x**y
function without name is anonymous function(used to pass a function into another function)

map function applies a function(arg 1) to all elements of arg 2 
filter function filters arg 2 with arg 1 condition(result = filter(lambda x:len(x)>6, fellowship))
reduce function applies function arg 1 in a series to all elements of args 2

## Exceptions
use try, except blocks to catch exceptions
TypeError to check for type exceptions
Raise ValueError to specify unacceptable values

##Iterators
convert iterable into iterator --> it = iter(iterable)
use next(it) to go to next element of iterator
enumerate(avengers,start=10{to specify start index}) --> takes a iterable as argument and add index to it
zip(avengers,names) --> zip more that 1 iterabels together

##List comprehensions
new_num = [n + 1 for n in num]
num_pair = [(num1,num2) for num1 in range(2,4) for num2 in (4,6)]
even_num = [num for num in range(10) if num % 2 == 0]
even_num = [num if num % 2 == 0 else 0 for num in range(10)]
pos_neg = {num: -num for num in range(6)}   -->   Creating a dictionary

##generator
replace [] with () in list comprehensions to make a generator.
Generator is an iterator and behaves exactly like an iterator.
generator funtion   -->   instead of return, use yield in the function

##file generators
read 1 line from the file generator -->   file.readline()

##Reading data from files
Text file --> file = open(filename,mode='r'{for read only})
              text = file.read()  --> reading the text of the file
              file.close()  --> closing the file
              
              with open(filename,mode='r') as file:
              print(file.read())
              
              file.readline() --> read one line from the file
              
using numpy --> np.loadtxt(filename,delimiter=',',skiprows=1,usecols=[0,2])
                data = np.genfromtxt('titanic.csv', delimiter=',', names=True, dtype=None) --> {load different type of data}

##Import SAS files
from sastbdat import SAS7BDAT
  with SAS7BDAT(fname) as file:
    df_sas = file.to_data_frame()
    
##Import stata files
pd.read_stata(fname)

##Import HDF5 file
import h5py
data = h5py.file(fname,'r')

##Import mat file
import scipy.io
data = scipy.io.loadmat(fname)

##Import from DataBase
  from sqlalchemy import create_engine
  engine = create_engine('sqlite:///Northwind.sqlite')
  con = engine.connect()
  rs = con.execute("select * from Orders")
  df = pd.DataFrame(rs.fetchall())
  df.columns = rs.keys()
  con.close()
  /
  with engine.connect() as con
    rs = con.execute("select * from Orders")
    df = pd.DataFrame(rs.fetchmany(size=5))
    df.coumns = rs.keys()
